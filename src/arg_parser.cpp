#include "include/arg_parser.hpp"
#include "include/ascii_title.hpp"
#include <absl/strings/str_cat.h>
#include <absl/types/span.h>
#include <cassert>
#include <cxxopts.hpp>

ArgParser::ArgParser(int argc, const char* const* argv) {
  assert(argc > 0);

  try {
    cxxopts::Options options(*argv, ascii_title);

    options.add_option("", "s", "sequencer", "URL of the sequencer to use",
                       cxxopts::value<std::string>()->default_value(
                           "https://seq.ceremony.ethereum.org"),
                       "");

    options.add_option(
        "", "a", "auth",
        "Authentication provider to use. Choices: [ethereum, github]",
        cxxopts::value<std::string>()->default_value("ethereum"), "");

    options.add_option(
        "", "m", "mode",
        "Mode to use. `complete` mode goes through the whole process on a "
        "single machine. `internet` mode downloads the transcript from and "
        "submits the contribution to the sequencer, but doesn't generate any "
        "secrets or sign anything. `airgapped` mode is meant to be used on a "
        "computer without internet connection and takes a `contribution.json` "
        "file generated by a machine in `internet` mode, computes the powers "
        "of tau and updates the `contribution.json` file. Choices: [complete, "
        "internet, airgapped]",
        cxxopts::value<std::string>()->default_value("complete"), "");

    options.add_option("", "c", "contribution-file-path",
                       "Path to the contribution.json file used for the "
                       "`internet` and `airgapped` modes.",
                       cxxopts::value<std::string>(), "");

    options.add_option(
        "", "e", "entropy",
        "Type of entropy to use for the first layer. Additional CSPRNG entropy "
        "will be applied on top of it. Choices: [stdin]",
        cxxopts::value<std::string>()->default_value("stdin"), "");

    options.add_option(
        "", "n", "no-signing",
        "Disable the signing of the contribution. Although signing "
        "contributions is not mandatory, it is recommended to verify that the "
        "contributions listed in the transcript are actually generated by the "
        "addresses listed.",
        cxxopts::value<bool>()->default_value("false"), "");

    options.add_option("", "p", "port",
                       "Port to run the authentication server on. If not "
                       "provided, a random port will be chosen.",
                       cxxopts::value<uint16_t>(), "");

    options.add_option(
        "", "", "sessionid",
        "Manually specify the session id to use for authentication. The "
        "session ID can be generated on a machine that has browser support, "
        "and then manually entered here for machines without a browser.",
        cxxopts::value<std::string>(), "");

    options.add_option(
        "", "", "nickname",
        "Manually specify the nickname to use for authentication. For Ethereum "
        "authentication, the address is required; for GitHub authentication, "
        "the GitHub username is required instead. This option is required when "
        "--sessionid is specified.",
        cxxopts::value<std::string>(), "");

    options.add_option("", "h", "help", "Print usage", cxxopts::value<bool>(),
                       "");

    help_message_ = options.help();
    auto parse_result = options.parse(argc, argv);

    help_wanted_ = parse_result.count("help") > 0;
    if (!help_wanted_) {
      sequencer_url_ = parse_result["sequencer"].as<std::string>();
      signing_disabled_ = parse_result["no-signing"].as<bool>();
    }

    const auto auth_provider = parse_result["auth"].as<std::string>();
    if (auth_provider == "ethereum") {
      auth_provider_ = AuthProvider::Ethereum;
    } else if (auth_provider == "github") {
      auth_provider_ = AuthProvider::GitHub;
    } else {
      throw std::runtime_error(absl::StrCat("invalid authentication provider `",
                                            auth_provider, "`"));
    }

    const auto mode = parse_result["mode"].as<std::string>();
    if (mode == "complete") {
      client_mode_ = ClientMode::Complete;
    } else if (mode == "airgapped") {
      client_mode_ = ClientMode::Airgapped;

      if (parse_result.count("contribution-file-path") == 0) {
        throw std::runtime_error("the `contribution-file-path` argument must "
                                 "be present when in `airgapped` mode");
      }

      contribution_file_path_ =
          parse_result["contribution-file-path"].as<std::string>();
    } else if (mode == "internet") {
      client_mode_ = ClientMode::Internet;

      if (parse_result.count("contribution-file-path") == 0) {
        throw std::runtime_error("the `contribution-file-path` argument must "
                                 "be present when in `internet` mode");
      }

      contribution_file_path_ =
          parse_result["contribution-file-path"].as<std::string>();
    } else {
      throw std::runtime_error(absl::StrCat(
          "Invalid mode `", mode,
          "`. Valid modes are `complete`, `airgapped` and `internet`."));
    }

    const auto entropy_type = parse_result["entropy"].as<std::string>();
    if (entropy_type == "stdin") {
      entropy_type_ = EntropyType::Stdin;
    } else {
      throw std::runtime_error(
          absl::StrCat("invalid entropy type `", entropy_type, "`"));
    }

    if (parse_result.count("port") > 0) {
      port_ = parse_result["port"].as<uint16_t>();
    }

    if (parse_result.count("sessionid") > 0) {
      session_id_ = parse_result["sessionid"].as<std::string>();

      if (parse_result.count("nickname") > 0) {
        nickname_ = parse_result["nickname"].as<std::string>();
      } else {
        throw std::runtime_error(
            "--nickname is required when --sessionid is specified");
      }
    }

  } catch (const cxxopts::option_not_exists_exception& ex) {
    throw std::runtime_error(absl::StrCat(
        "error when parsing arguments: ", ex.what(), "\n", help_message_));
  }
}

static std::vector<uint8_t> get_stdin_entropy() {
  std::cout << "Write a sentence to generate entropy: " << std::endl;
  std::string entropy;
  std::cin >> entropy;
  return {entropy.begin(), entropy.end()};
}

std::vector<uint8_t> ArgParser::get_entropy() const {
  switch (entropy_type_) {
  case EntropyType::Stdin:
    return get_stdin_entropy();
  default:
    throw std::runtime_error("Invalid entropy type");
  }
}
