#include "include/arg_parser.hpp"
#include "include/ascii_title.hpp"
#include <absl/strings/str_cat.h>
#include <absl/types/span.h>
#include <cassert>
#include <cxxopts.hpp>

ArgParser::ArgParser(int argc, const char* const* argv) {
  assert(argc > 0);

  try {
    cxxopts::Options options(*argv, ascii_title);

    options.add_option("", "s", "sequencer", "URL of the sequencer to use",
                       cxxopts::value<std::string>()->default_value(
                           "https://seq.ceremony.ethereum.org"),
                       "");

    options.add_option(
        "", "a", "auth",
        "Authentication provider to use. Choices: [ethereum, github]",
        cxxopts::value<std::string>()->default_value("ethereum"), "");

    options.add_option(
        "", "e", "entropy",
        "Type of entropy to use for the first layer. Additional CSPRNG entropy "
        "will be applied on top of it. Choices: [stdin]",
        cxxopts::value<std::string>()->default_value("stdin"), "");

    options.add_option(
        "", "n", "no-signing",
        "Disable the signing of the contribution. Although signing "
        "contributions is not mandatory, it is recommended to verify that the "
        "contributions listed in the transcript are actually generated by the "
        "addresses listed.",
        cxxopts::value<bool>()->default_value("false"), "");

    options.add_option("", "h", "help", "Print usage", cxxopts::value<bool>(),
                       "");

    help_message_ = options.help();
    auto parse_result = options.parse(argc, argv);

    help_wanted_ = parse_result.count("help") > 0;
    if (!help_wanted_) {
      sequencer_url_ = parse_result["sequencer"].as<std::string>();
      signing_disabled_ = parse_result["no-signing"].as<bool>();
    }

    const auto auth_provider = parse_result["auth"].as<std::string>();
    if (auth_provider == "ethereum") {
      auth_provider_ = AuthProvider::Ethereum;
    } else if (auth_provider == "github") {
      auth_provider_ = AuthProvider::GitHub;
    } else {
      throw std::runtime_error(absl::StrCat("invalid authentication provider `",
                                            auth_provider, "`"));
    }

    const auto entropy_type = parse_result["entropy"].as<std::string>();
    if (entropy_type == "stdin") {
      entropy_type_ = EntropyType::Stdin;
    } else {
      throw std::runtime_error(
          absl::StrCat("invalid entropy type `", entropy_type, "`"));
    }
  } catch (const cxxopts::option_not_exists_exception& ex) {
    throw std::runtime_error(absl::StrCat(
        "error when parsing arguments: ", ex.what(), "\n", help_message_));
  }
}

static std::vector<uint8_t> get_stdin_entropy() {
  std::cout << "Write a sentence to generate entropy: " << std::endl;
  std::string entropy;
  std::cin >> entropy;
  return {entropy.begin(), entropy.end()};
}

std::vector<uint8_t> ArgParser::get_entropy() const {
  switch (entropy_type_) {
  case EntropyType::Stdin:
    return get_stdin_entropy();
  default:
    throw std::runtime_error("Invalid entropy type");
  }
}
