#include "include/arg_parser.hpp"
#include "include/ascii_title.hpp"
#include "include/auth_request_link.hpp"
#include "include/batch_contribution.hpp"
#include "include/bls_signature.hpp"
#include "include/contribution_schema.hpp"
#include "include/identity_fetcher.hpp"
#include "include/port_picker.hpp"
#include "include/power.hpp"
#include "include/secret_generator.hpp"
#include "include/server.hpp"
#include "include/signing_browser.hpp"
#include <absl/strings/str_cat.h>
#include <absl/strings/str_split.h>
#include <cpr/cpr.h>
#include <iostream>

using nlohmann::json;

namespace airgapped_flow {
void launch(const ArgParser& arg_parser) {
  std::cout << "Reading the contribution file from `"
            << arg_parser.get_contribution_file_path() << "`" << std::endl;

  json batch_contribution_json;
  {
    std::ifstream json_file_stream(arg_parser.get_contribution_file_path());

    if (json_file_stream.fail()) {
      throw std::runtime_error(
          absl::StrCat("failed to open the contribution file located at `",
                       arg_parser.get_contribution_file_path(), "`"));
    }

    batch_contribution_json = json::parse(json_file_stream);
  }

  // Extract the identity from the json file
  auto identity_iter = batch_contribution_json.find("identity");
  if (identity_iter == batch_contribution_json.end()) {
    throw std::runtime_error(
        "`Identity` key not found at the root of the json file. Are you sure "
        "that this file was generated by the cpp-kzg-ceremony-client in "
        "`internet` mode?");
  }

  const auto identity = identity_iter->get<std::string>();
  batch_contribution_json.erase(identity_iter);

  BatchContribution batch_contribution(batch_contribution_json,
                                       json::parse(contribution_schema));

  // Validate the powers
  batch_contribution.validate_powers();

  // Generate one secret for each contribution
  std::cout << "Generating secrets" << std::endl;
  static constexpr size_t num_secrets = 4;
  SecretGenerator<> secret_generator(arg_parser.get_entropy(), num_secrets);

  const auto& auth_provider = arg_parser.get_auth_provider();

  uint16_t port = 0;
  if (arg_parser.get_port().has_value()) {
    port = *arg_parser.get_port();
  } else {
    port = port_picker::pick_unused_port();
  }

  std::promise<AuthInfo> auth_info_promise;
  auto auth_callback = [&auth_info_promise](AuthInfo&& auth_info) {
    auth_info_promise.set_value(std::move(auth_info));
  };

  // Generate the pot pubkeys
  std::vector<std::string> pot_pubkeys;
  pot_pubkeys.reserve(secret_generator.get_secrets().size());

  std::cout << "Generating the pot pubkeys" << std::endl;
  // Sign the identity with the secrets
  for (const auto& secret : secret_generator.get_secrets()) {
    auto pot_pubkey = G2Power::generate_pot_pubkey(secret);
    pot_pubkeys.push_back(pot_pubkey.encode());
  }

  std::promise<std::string> ecdsa_signature_promise;
  auto ecdsa_signature_callback =
      [&ecdsa_signature_promise](std::string&& signature) {
        ecdsa_signature_promise.set_value(std::move(signature));
      };

  std::vector<PotPubkeyMessage> pot_pubkey_messages;
  pot_pubkey_messages.reserve(pot_pubkeys.size());

  auto contributions = batch_contribution.get_contributions();
  for (size_t i = 0; i < pot_pubkeys.size(); ++i) {
    const auto& pot_pubkey = pot_pubkeys[i];
    const auto& contribution = contributions[i];
    int num_g1_powers = contribution.get_num_g1_powers();
    int num_g2_powers = contribution.get_num_g2_powers();
    pot_pubkey_messages.emplace_back(num_g1_powers, num_g2_powers, pot_pubkey);
  }

  Server server(port, std::move(auth_callback), ecdsa_signature_callback,
                pot_pubkey_messages);

  std::string ecdsa_signature;
  if (auth_provider == AuthProvider::Ethereum &&
      !arg_parser.signing_disabled() && ecdsa_signature.empty()) {

    std::vector<absl::string_view> identity_parts =
        absl::StrSplit(identity, '|');

    auto eth_address = identity_parts[1];
    const auto signing_url = absl::StrCat("http://localhost:", port,
                                          "/sign?eth_address=", eth_address);

    SigningBrowser signing_browser(signing_url);
    auto ecdsa_signature_future = ecdsa_signature_promise.get_future();
    ecdsa_signature = ecdsa_signature_future.get();
  }

  std::vector<std::string> bls_signatures;
  bls_signatures.reserve(secret_generator.get_secrets().size());

  // Sign the identity with the secrets
  for (const auto& secret : secret_generator.get_secrets()) {
    auto pot_pubkey = G2Power::generate_pot_pubkey(secret);
    pot_pubkeys.push_back(pot_pubkey.encode());

    BlsSignature bls_signature(secret, identity);
    bls_signatures.push_back(bls_signature.encode());
  }

  // Update the powers of Tau with the secrets generated earlier
  std::cout << "Updating the contributions" << std::endl;
  const auto secrets = secret_generator.get_secrets();

  for (size_t i = 0; i < contributions.size(); ++i) {
    auto& contribution = contributions[i];
    contribution.update_powers_of_tau(secrets[i]);
    contribution.set_pot_pubkey(std::move(pot_pubkeys[i]));
    contribution.set_bls_signature(std::move(bls_signatures[i]));
  }

  if (!ecdsa_signature.empty()) {
    std::cout << "Setting the ecdsa signature" << std::endl;
    batch_contribution.set_ecdsa_signature(std::move(ecdsa_signature));
  }

  std::cout << "Saving the contribution file to `"
            << arg_parser.get_contribution_file_path() << "`" << std::endl;
  {
    std::ofstream batch_contribution_stream(
        arg_parser.get_contribution_file_path());
    if (batch_contribution_stream.fail()) {
      throw std::runtime_error(
          absl::StrCat("failed to save the contribution file to `",
                       arg_parser.get_contribution_file_path(), "`"));
    }

    batch_contribution_stream << json(batch_contribution);
  }

  std::cout << "The contribution file has been saved to `"
            << arg_parser.get_contribution_file_path()
            << "`. You can now transfer this file over to the "
               "internet-connected machine and resume the program to submit "
               "your contribution to the sequencer."
            << std::endl;
}
} // namespace airgapped_flow
